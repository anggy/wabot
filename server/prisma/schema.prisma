generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Session {
  id        String   @id
  name      String
  status    String   @default("DISCONNECTED")
  config    String?
  userId    Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
}

model Rule {
  id                Int      @id @default(autoincrement())
  name              String
  triggerType       String
  triggerValue      String
  actionType        String
  apiUrl            String?
  apiMethod         String?  @default("POST")
  apiPayload        String?
  responseContent   String?
  responseMediaType String?  @default("TEXT")
  responseMediaUrl  String?
  isActive          Boolean  @default(true)
  sessionId         String?  // Optional, if null it applies to all sessions
  filterGroupId     String?  // Optional: Specific Group JID
  credentialId      Int?
  credential        AiCredential? @relation(fields: [credentialId], references: [id])
  userId            Int      @default(1)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id])
}

model Schedule {
  id             Int       @id @default(autoincrement())
  sessionId      String
  recipient      String
  messageType    String
  content        String
  mediaUrl       String?
  actionType     String    @default("TEXT") // TEXT, IMAGE, AI_REPLY, API_CALL
  apiUrl         String?
  apiMethod      String?   @default("GET")
  apiPayload     String?
  credentialId   Int?
  credential     AiCredential? @relation(fields: [credentialId], references: [id])
  cronExpression String
  lastRun        DateTime?
  isActive       Boolean   @default(true)
  userId         Int       @default(1)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  user           User      @relation(fields: [userId], references: [id])
}

model MessageLog {
  id        Int      @id @default(autoincrement())
  sessionId String
  direction String
  from      String
  to        String
  content   String
  status    String
  createdAt DateTime @default(now())
}

model Contact {
  id        Int      @id @default(autoincrement())
  name      String
  phone     String   @unique
  tags      String?
  userId    Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
}

model User {
  id            Int        @id @default(autoincrement())
  username      String     @unique
  email         String?
  phone         String?
  password      String
  role          String     @default("USER")
  credits       Int        @default(0)
  planType      String     @default("PAY_AS_YOU_GO")
  planExpiresAt DateTime?
  messageCost   Int        @default(1)
  aiApiKey      String?
  aiProvider    String     @default("openai") // openai, gemini
  aiBriefing    String?
  isAiEnabled   Boolean    @default(false)
  isActive      Boolean    @default(true)
  createdAt     DateTime   @default(now())
  contacts      Contact[]
  rules         Rule[]
  schedules     Schedule[]
  sessions      Session[]
  broadcasts    Broadcast[]
  aiTools       AiTool[]
  credentials   AiCredential[]
}

model Broadcast {
  id        Int            @id @default(autoincrement())
  sessionId String
  name      String?        // e.g. "Campaign #1"
  tag       String
  messageType String
  content   String
  mediaUrl  String?
  actionType String          @default("TEXT") // TEXT, IMAGE, AI_REPLY, API_CALL
  apiUrl     String?
  apiMethod  String?         @default("GET")
  apiPayload String?
  credentialId Int?
  credential AiCredential?   @relation(fields: [credentialId], references: [id])
  total     Int            @default(0)
  sent      Int            @default(0)
  failed    Int            @default(0)
  status    String         @default("PROCESSING") // PROCESSING, COMPLETED
  userId    Int
  user      User           @relation(fields: [userId], references: [id])
  cratedAt  DateTime       @default(now())
  logs      BroadcastLog[]
}

model BroadcastLog {
  id          Int       @id @default(autoincrement())
  broadcastId Int
  contactName String?
  contactPhone String
  status      String    // PENDING, SUCCESS, FAILED
  errorMessage String?
  broadcast   Broadcast @relation(fields: [broadcastId], references: [id])
  createdAt   DateTime  @default(now())
}

model AiTool {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String
  method      String   @default("GET")
  baseUrl     String
  endpoint    String
  parameters  String   // Stored as JSON string
  headers     String?  // Stored as JSON string
  body        String?  // Stored as JSON string
  authType    String   @default("NONE") // NONE, API_KEY, BEARER
  authRefreshUrl String? // URL to fetch new token (POST)
  authRefreshPayload String? // JSON body for refresh (client_id, secret, etc)
  authTokenPath String? // JSON path to find token in response (e.g. "access_token" or "data.token")
  
  credentialId Int?
  credential   AiCredential? @relation(fields: [credentialId], references: [id])

  isEnabled   Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])
  userId      Int      @default(1)
}

model AiCredential {
  id          Int      @id @default(autoincrement())
  name        String
  type        String   @default("API_KEY") // API_KEY, BEARER
  key         String?  // e.g. "X-API-KEY", empty for Bearer
  value       String   // The secret token
  location    String   @default("HEADER") // HEADER, QUERY
  
  // Auto-Refresh Logic
  refreshUrl      String?
  refreshPayload  String?
  tokenPath       String?

  userId      Int
  user        User     @relation(fields: [userId], references: [id])
  
  tools       AiTool[]
  rules       Rule[]
  schedules   Schedule[]
  broadcasts  Broadcast[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, name])
}
